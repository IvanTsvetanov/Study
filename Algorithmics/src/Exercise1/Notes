Q1:

(a)
-Modify TestSort to measure the running time of different sizes of arrays. (1)
-Plot a graph of the average run time against the size of the input.
(For this you will need to run the three algorithms for several arrays of the same size) // NEED TO PUT ALL THE TIME RECORDS IN A CLASS FOE EASIER ACCESS
-Note: Your answer should only include a brief summary of the modifications made to the code, and the graph mentioned above.

(1) To do measure the running time of different sizes of arrays we must create, for example, two more arrays with modified sizes:
eg.
        //CREATE MORE VARIABLES TO STORE THE LENGTHS OF THE ARRAYS
        int N = 1000;
        int smallerN = 500;
        int evenSmallerN = 100;
        int biggerN = 2500;

        //CREATE MORE ARRAYS WITH THE MODIFIED SIZES
        double[] data = new double[N];
        double[] smallerData = new double[smallerN];
        double[] evenSmallerData = new double[evenSmallerN];
        double[] biggerData = new double[biggerN];

Then we must populate the arrays, via for loops, using the Math.random method().
(Math.random returns a double type number greater than or equal to 0.0 and less than 1.0.)

Afterwards we must create 3 data containers (arrays) for each of the previously created arrays (data, smallerData, evenSmallerData and biggerData).
The created sub-containers are copies of the arrays.
eg.
        //Put all the data from the original array in these ones
        double[] data1 = (double[])data.clone();
        double[] data2 = (double[])data.clone();
        double[] data3 = (double[])data.clone();

        double[] smallerData1 = (double[])smallerData.clone();
        double[] smallerData2 = (double[])smallerData.clone();
        double[] smallerData3 = (double[])smallerData.clone();

        double[] evenSmallerData1 = (double[])evenSmallerData.clone();
        double[] evenSmallerData2 = (double[])evenSmallerData.clone();
        double[] evenSmallerData3 = (double[])evenSmallerData.clone();

        double[] biggerData1 = (double[])biggerData.clone();
        double[] biggerData2 = (double[])biggerData.clone();
        double[] biggerData3 = (double[])biggerData.clone();

Moving forward, we must call each of three algorithms (insertion, shell and quick sort) for each of the sub-data containers (for data those would be data1, data2, data3).
Example for smallerData:

        //Calls the first method
        InsertionSort(smallerData1);
        time = (System.nanoTime()-time_prev_smaller)/1000000000.0;
        System.out.println("Insertion Sort\nTime= " + time);
        time_prev_smaller = System.nanoTime();

        //Calls the second method
        ShellSort(smallerData2);
        time = (System.nanoTime()-time_prev_smaller)/1000000000.0;
        System.out.println("Shell Sort\nTime= " + time);
        time_prev_smaller = System.nanoTime();

        //Calls the third method
        Arrays.sort(smallerData3);
        time = (System.nanoTime()-time_prev_smaller)/1000000000.0;
        System.out.println("Quick Sort\nTime= " + time);

In the end, if we want to display all the items (numbers) in the array (smallerData) we could use the following:

        //Display all the info
        System.out.println("SMALLER-DATA");
        System.out.println("\tPresorted\tInsertion\t\t Shell\t\t Quick");
        for (int i=0; i<smallerData.length; i++)
            System.out.println(smallerData[i] + " " + smallerData1[i] + " " + smallerData2[i] + " " + smallerData3[i]);